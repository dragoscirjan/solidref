---
language: JavaScript (ECMAScript)
code: javascript
birth: 1995
description: A collection of widely-accepted coding principles that guide software design and development.
principles:
  - title: Single Responsibility Principle (SRP)
    examples:
      - title: Good Example
        code: |
          // Good example: Splitting responsibilities into separate classes
          class UserDataManager {
              saveUserData() { /* ... */ }
          }

          class UserNotification {
              sendNotification() { /* ... */ }
          }

      - title: Bad Example
        code: |
          // Bad example: A class handling both user data management and user notifications
          class User {
              saveUserData() { /* ... */ }
              sendNotification() { /* ... */ }
          }

  - title: Open/Closed Principle (OCP)
    examples:
      - title: Good Example
        code: |
          // Good example: Using abstraction to allow extension without modification
          function computeArea(shape) {
              return shape.computeArea();
          }

          const rectangle = {
              computeArea: function() {
                  return this.width * this.height;
              },
              width: 10,
              height: 5
          };

          const circle = {
              computeArea: function() {
                  return 3.14 * this.radius * this.radius;
              },
              radius: 5
          }

      - title: Bad Example
        code: |
          // Bad example: Modifying existing code to add new functionality
          function AreaCalculator(shape) {
              if (shape.type === 'rectangle') {
                  return shape.width * shape.height;
              } else if (shape.type === 'circle') {
                  return 3.14 * shape.radius * shape.radius;
              }
          }

  - title: Liskov Substitution Principle (LSP)
    examples:
      - title: Good Example
        code: |
          // Good example: Derived classes maintain the behavior of the base class
          class FlyingBird {
              fly() { /* ... */ }
          }

          class NonFlyingBird {
              walk() { /* ... */ }
          }

      - title: Bad Example
        code: |
          // Bad example: Derived class changes the behavior of the base class
          class Bird {
              fly() { /* ... */ }
          }

          class Ostrich extends Bird {
              fly() {
                  throw new Error("Can't fly");
              }
          }

  - title: Interface Segregation Principle (ISP)
    examples:
      - title: Good Example
        code: |
          // Good example: Breaking down the function into more specific ones
          function createPerson(name, age) { /* ... */ }
          function assignTask(worker, task) { /* ... */ }
          function feedWorker(worker, food) { /* ... */ }

      - title: Bad Example
        code: |
          // Bad example: A function requiring many parameters
          function createWorker(name, age, task, food) { /* ... */ }

  - title: Dependency Inversion Principle (DIP)
    examples:
      - title: Good Example
        code: |
          // Good example: Both high-level and low-level modules depend on abstractions
          class Switch {
              constructor(device) {
                  this.device = device;
              }
              operate() {
                  this.device.turnOn();
              }
          }

          const fan = {
              turnOn: function() { /* ... */ }
          }

      - title: Bad Example
        code: |
          // Bad example: High-level module depending on a low-level module
          class LightBulb {
              turnOn() { /* ... */ }
          }

          class Switch {
              constructor(bulb) {
                  this.bulb = bulb;
              }
              operate() {
                  this.bulb.turnOn();
              }
          }

  - title: DRY (Don't Repeat Yourself)
    examples:
      - title: Good Example
        code: |
          // Good example: Single function for repeated logic
          function addTax(price, rate = 0.05) {
              return price + (price * rate);
          }

      - title: Bad Example
        code: |
          // Bad example: Repeated logic
          function addTaxForFood(price) {
              return price + (price * 0.05);
          }

          function addTaxForElectronics(price) {
              return price + (price * 0.05);
          }

  - title: KISS (Keep It Simple, Stupid)
    examples:
      - title: Good Example
        code: |
          // Good example: Simplified approach
          function isEven(num) {
              return num % 2 === 0;
          }

      - title: Bad Example
        code: |
          // Bad example: Overcomplicated way to check even numbers
          function isEven(num) {
              return num % Math.abs(2) === 0;
          }

  - title: YAGNI (You Aren't Gonna Need It)
    examples:
      - title: Good Example
        code: |
          // Good example: Only implement what's needed
          class Car {
              drive() { /* ... */ }
          }

      - title: Bad Example
        code: |
          // Bad example: Adding unnecessary features
          class Car {
              drive() { /* ... */ }
              fly() { /* ... */ }  // Cars don't fly!

  - title: Law of Demeter (Principle of Least Knowledge)
    examples:
      - title: Good Example
        code: |
          // Good example: Using encapsulation
          class Wallet {
              constructor() {
                  this._money = 100;
              }
              getAmount() {
                  return this._money;
              }
          }

          class Person {
              constructor() {
                  this.wallet = new Wallet();
              }
              getMoneyAmount() {
                  return this.wallet.getAmount();
              }
          }

          function purchase(item, buyer) {
              if (buyer.getMoneyAmount() >= item.price) { /* ... */ }
          }

      - title: Bad Example
        code: |
          // Bad example: Accessing nested structures directly
          class Wallet {
              constructor() {
                  this.money = { amount: 100 };
              }
          }

          class Person {
              constructor() {
                  this.wallet = new Wallet();
              }
          }

          function purchase(item, buyer) {
              if (buyer.wallet.money.amount >= item.price) { /* ... */ }
          }

  - title: Separation of Concerns
    examples:
      - title: Good Example
        code: |
          // Good example: Separating concerns into different modules
          class UserDataService {
              fetchUserData() { /* ... */ }
          }

          class UserLogic {
              calculateAge() { /* ... */ }
          }

          class UserComponent {
              render() { /* ... */ }
          }

      - title: Bad Example
        code: |
          // Bad example: Mixing data retrieval and presentation
          class UserComponent {
              fetchUserData() { /* ... */ }
              render() { /* ... */ }
              calculateAge() { /* ... */ }
          }
