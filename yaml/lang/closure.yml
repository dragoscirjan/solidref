---
language: ClojureScript
code: clojure
parent: javascript
birth: 2011
description: A compiler for Clojure that targets JavaScript. It brings the power of Clojure (a functional Lisp dialect) to web development.
principles:
  - title: Single Responsibility Principle (SRP)
    code: |
      ;; Bad example: A namespace handling both user data management and user notifications
      (ns user)

      (defn save-user-data [data]
        ;; ...
        )

      (defn send-notification [notification]
        ;; ...
        )

      ;; Good example: Splitting responsibilities into separate namespaces
      (ns user-data-manager)

      (defn save-user-data [data]
        ;; ...
        )

      (ns user-notification)

      (defn send-notification [notification]
        ;; ...
        )
  - title: Open/Closed Principle (OCP)
    code: |
      ;; Using multi-methods to represent different shapes and their areas
      (defmulti compute-area :shape)

      (defmethod compute-area :rectangle [{:keys [width height]}]
        (* width height))

      (defmethod compute-area :circle [{:keys [radius]}]
        (* 3.14 radius radius))
  - title: Liskov Substitution Principle (LSP)
    code: "Given that Clojure is a dynamically-typed language, the LSP doesn't apply in the same way as in statically-typed languages. However, when using polymorphism (like multi-methods), it's essential to ensure that all implementations are substitutable."
  - title: Interface Segregation Principle (ISP)
    code: "Clojure doesn't have interfaces or classes in the traditional sense. However, protocols in Clojure can be seen as a way to define interfaces. Using protocols and multi-methods, you can define clear contracts and invert dependencies."
  - title: Dependency Inversion Principle (DIP)
    code: |
      ;; Using Higher-Order Functions
      (defn greet [formatter name]
        (formatter name))

      (defn polite-formatter [name]
        (str "Hello, " name "! How are you today?"))

      (defn casual-formatter [name]
        (str "Hey, " name "!"))

      ;; Usage
      (greet polite-formatter "Alice")  ;; "Hello, Alice! How are you today?"
      (greet casual-formatter "Bob")    ;; "Hey, Bob!"
  - title: DRY (Don't Repeat Yourself)
    code: |
      ;; Bad example: Repeated logic
      (defn add-tax-for-food [price]
        (+ price (* price 0.05)))

      (defn add-tax-for-electronics [price]
        (+ price (* price 0.05)))

      ;; Good example: Single function for repeated logic
      (defn add-tax [price & [rate]]
        (+ price (* price (or rate 0.05))))
  - title: KISS (Keep It Simple, Stupid)
    code: |
      ;; Bad example: Overcomplicated way to check even numbers
      (defn is-even [num]
        (zero? (mod (if (> num 0) num (- num)) 2)))

      ;; Good example: Simplified approach
      (defn is-even [num]
        (zero? (mod num 2)))
  - title: YAGNI (You Aren't Gonna Need It)
    code: |
      ;; Bad example: Adding unnecessary features
      (defprotocol CarActions
        (drive [this])
        (fly [this]))  ;; Cars don't fly!

      ;; Good example: Only implement what's needed
      (defprotocol CarActions
        (drive [this]))
  - title: Law of Demeter (Principle of Least Knowledge)
    code: |
      ;; Bad example: Accessing nested structures directly
      (defn purchase [item-price {:keys [wallet]}]
        (let [{:keys [money]} wallet]
          (>= money item-price)))

      ;; Good example: Using destructuring to minimize knowledge
      (defn purchase [item-price {:keys [wallet]}]
        (let [money (:money wallet)]
          (>= money item-price)))
  - title: Separation of Concerns
    code: |
      ;; Bad example: Mixing data retrieval and presentation in one namespace
      (ns user)

      (defn fetch-user-data []
        ;; ...
        )

      (defn render-user [user]
        ;; ...
        )

      ;; Good example: Separating concerns into different namespaces
      (ns user-data)

      (defn fetch-user-data []
        ;; ...
        )

      (ns user-view)

      (defn render-user [user]
        ;; ...
        )
